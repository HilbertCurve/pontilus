Windows is hard.

OpenGL:
    An OpenGL program has shaders, vertex buffers, a window, a camera, mouse/keyboard callbacks, 
    and the rest of the program logic. 
    [+] Application.cpp - inits everything / sets up a window / sets up callbacks
    [+] Camera.cpp - camera
    [+] Renderer.cpp - renders stuff
    [+] Shader.cpp - handles getting shader data
    [+] Texture.cpp - textures, when that becomes necessary
    [+] IconMap.cpp - collections of textures / spritesheets
    [+] InputListener.cpp - mouse and keyboard callbacks/data
    [-] RenderBatch.cpp - a way to contain a lot of a single primitive type

Misc:
    [-] Math.cpp - maybe later
    [+] Primitive.cpp - basic renderable primitives
    [+] rData.cpp - renderable data
    [+] Add https://github.com/kcat/openal-soft pull and install to Dockerfile
    [+] Zip together include and src directory
    [+] Update dockerfile after refactoring
    Best Practices:
        [ ] const-qualify appropriate functions everywhere
        [ ] Use forward declarations instead of #includes in header files

Postprocessing:
    [+] PointMap.cpp - a way to update/process points
    [+] Point light demo - a demonstration of how to use point maps for lighting effects
    [ ] More to come...

ECS:
    [+] Component.h - these can be attached to GameObjects to give various engines control over the go's fields
    [+] SpriteRenderer.h - migrate toRData() calls here
    Animations:
        [ ] Move GameObject.color into Texture
        [+] Animation.h - a component that updates a SpriteRenderer's texture; requires the GameObject to have a SpriteRenderer
    [ ] Body2D.cpp - convert physics body into a component

UI:
    [ ] TextRenderer.cpp - basic renderable component with a std::string field
    [ ] TextField.cpp - a Text, but submits a key callback when focused on that updates the text inside
    [ ] Icon.cpp - a game object with a texture handle

Audio:
    [+] AudioListener.cpp - the component wrapper over the OpenAL audio listener
    [+] AudioSource.cpp - the component wrapper over OpenAL audio sources
    [+] AudioMaster.cpp - .wav files and an audio system
    [+] Audio buffering
    [+] Audio playing and stopping
    [ ] Audio file buffering - stream directly from the audio file

AssetPool:
    [ ] AssetPool.cpp - a way to generate audio, image, shader, font, etc. structs in one place (needed for Python)

Events:
    An event has an array of function pointers which are all called 
    in a "triggerEvent()" call
    [ ] Events.cpp - an enumeration of all the types of events
    [ ] Properly use Events.cpp throughout the project

Physics:
    [+] Math utils

    2D:
        Every collision is resolved in 3 steps. First the collision
        is detected. Next the collision point is calculated and 
        velocity/angular velocity data is collected. Finally the collision
        is resolved. The three steps will be separated into 2 functions, one
        for collision detection and data collection and one for resolution.

        [+] Body declarations

        Point-Triangle will help with polygon and box2d collisions.
        [ ] Point-Triangle collision

        [+] Circle-circle collision
        [+] Circle-AABB collision
        Accelerated Box-AABB collision, in case rotation is not permitted.
        [+] AABB-AABB collision
        [ ] Box2D-AABB collision
        If we have Box-AABB, we have Box-box; we just need to rotate both boxes around
        one box's center and treat it as an AABB temporarily.
        [ ] Polygon-Circle collision
        [ ] Polygon-AABB collision
        [ ] Polygon-Polygon collision

        Collision resolution:
            [ ] Test idea where velocities are set based on a pair of points and a reflection of the velocity

        [ ] Go back and optimize (try to remove sqrts & trig if possible)
    3D:
        [ ] Sphere-sphere collision
        [ ] Sphere-AABB collision
        [ ] AABB-AABB collision
        [ ] Box3D-AABB collision
        [ ] ...

Pontilus Language
    I probably have a terrible idea, but what if scene functions are transpiled from 
    a custom language into C, JIT-compiled, then ran??? This would separate the engine
    from the game code, and making a custom language looks good on my portfolio...
    However, that's not necessary... If I ever take a compiler course I might consider it.
    Maybe I could use Rift...
    It'd be better if I used Python with CPython, to be honest
    I have come to the conclusion of using Python. Ports to other languages will come next...?

Deployment (handling of...):
    [+] Non-existent audio drivers
    [ ] Different OpenGL versions
    [ ] Configurable assets folder
    [+] Default scene if one isn't set

Python:
    I'm putting this on hold for now.

    First, you initialize the library by calling Pontilus::init()
    Then you specify your scene objects.
    Then you call Pontilus::loop()
    [+] Figure out how to use CPython
    [-] Add argument parsing
    My thinking is that we have a bunch of functions return ints whenever they could throw
    [ ] Add exception throwing (so python doesn't just crash whenever it tries to open a file)

    Exposing Library:
        [ ] Expose ECS datatypes & funcs
        [ ] Expose Graphics datatypes & funcs
        [+] Expose Audio datatypes & funcs
        [ ] Expose Core datatypes & funcs
        [-] Exposing physics will have to wait

State Machines:
    [+] StateMachine.cpp - Design a state machine component
    [+] Indivitual states
    [+] Example state machine

Roadmap:
    [+] Get renderer chugging out things
    [+] Do github stuffs
    IO stuff:
        [+] Keyboard
        [+] Mouse
    [+] Refactoring
    [+] Textures and images
    [+] Rename Rend to rData
    [+] Render batches
    Batches aren't needed, we'll just use one large rData pool (which is basically a render batch)
    [+] Automatic rData allocation
    [+] Basic ECS
    [+] Pong demo
    [ ] Documentation
    [+] Animations
    [+] Audio
    [+] State machines
    [ ] 3D stuff
    [ ] Physics
    [ ] UI
    Make Some Games:
        [+] Basic platformer
        [ ] Mario clone
        [ ] RPG-ish
    
Issues:
    [+] Camera.cpp has wierd visual bugs involving an object rotating out of frame.
    It's because of it being orthographic instead of perspective
    [ ] Text isn't rendering properly; the edges of glyphs clip

Backburner:
    [ ] Python
    [ ] Windows build
    [ ] More debug messages

I'm taking a small break for now; trying to work on MIDI-fi a bit.

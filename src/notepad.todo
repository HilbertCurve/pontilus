Windows is hard.

OpenGL:
    An OpenGL program has shaders, vertex buffers, a window, a camera, mouse/keyboard callbacks, 
    and the rest of the program logic. 
    [+] Application.cpp - inits everything / sets up a window / sets up callbacks
    [+] Camera.cpp - camera
    [+] Renderer.cpp - renders stuff
    [+] Shader.cpp - handles getting shader data
    [+] Texture.cpp - textures, when that becomes necessary
    [+] InputListener.cpp - mouse and keyboard callbacks/data
    [-] RenderBatch.cpp - a way to contain a lot of a single primitive type

Misc:
    [-] Math.cpp - maybe later
    [+] Primitive.cpp - basic renderable primitives
    [+] rData.cpp - renderable data

Postprocessing:
    [+] PointMap.cpp - a way to update/process points
    [+] Point light demo - a demonstration of how to use point maps for lighting effects
    [ ] More to come

ECS:
    [ ] Component.h - these can be attached to GameObjects to give various engines control over the go's fields
    [ ] SpriteRenderer.h - migrate toRData() calls here
    [ ] Body2D.cpp - convert physics body into a component

UI:
    [ ] Text.cpp - basic text; a game object with an added std::string field
    [ ] TextField.cpp - a Text, but submits a key callback when focused on that updates the text inside
    [ ] Icon.cpp - a game object with a texture handle

Events:
    An event has an array of function pointers which are all called 
    in a "triggerEvent()" call
    [ ] Events.cpp - an enumeration of all the types of events
    [ ] Properly use Events.cpp throughout the project

Physics:
    [ ] Math utils

    2D:
        Every collision is resolved in 3 steps. First the collision
        is detected. Next the collision point is calculated and 
        velocity/angular velocity data is collected. Finally the collision
        is resolved. The three steps will be separated into 2 functions, one
        for collision detection and data collection and one for resolution.

        [+] Body declarations

        Point-Triangle will help with polygon and box2d collisions.
        [ ] Point-Triangle collision

        [ ] Circle-circle collision
        [ ] Circle-AABB collision
        Accelerated Box-AABB collision, in case rotation is not permitted.
        [ ] AABB-AABB collision
        [ ] Box2D-AABB collision
        If we have Box-AABB, we have Box-box; we just need to rotate both boxes around
        one box's center and treat it as an AABB temporarily.
        [ ] Polygon-Circle collision
        [ ] Polygon-AABB collision
        [ ] Polygon-Polygon collision

        [ ] Collision resolution

        [ ] Go back and optimize (try to remove sqrts & trig if possible)
    3D:
        [ ] Sphere-sphere collision
        [ ] Sphere-AABB collision
        [ ] AABB-AABB collision
        [ ] Box3D-AABB collision
        [ ] ...

Pontilus Language:
    I probably have a terrible idea, but what if scene functions are transpiled from 
    a custom language into C, JIT-compiled, then ran??? This would separate the engine
    from the game code, and making a custom language looks good on my portfolio...

Main Checklist:
    [+] Get renderer chugging out things
    [+] Do github stuffs
    IO stuff:
        [+] Keyboard
        [+] Mouse
    [+] Refactoring
    [+] Textures and images
    [+] Rename Rend to rData
    [+] Render batches
    Batches aren't needed, we'll just use one large rData pool (which is basically a render batch)
    [ ] Automatic rData allocation

    [ ] UI
    [ ] Basic ECS

    [ ] Physics

    [ ] Debug Camera.cpp
    [ ] Documentation
    

Issues:
    [ ] Camera.cpp has wierd visual bugs involving an object rotating out of frame.


Backburner:
    [ ] Windows build
 

Future Plans:
    [ ] Custom language?
